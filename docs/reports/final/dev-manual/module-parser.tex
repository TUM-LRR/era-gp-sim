\subsection{Parser}

Das \textit{Parser}-Modul übernimmt die Übersetzung des eingegebenen Textes in
die für das \textit{Architektur}-Modul lesbaren Syntaxbäume. Damit entspricht
dieses Modul größtenteils dem eigentlichen Assemblierer.

\subsubsection{Submodule}

Bei Erscheinen der Version 1.0 besteht das Parser-Modul aus vier verschiedenen Untermodulen:

\begin{itemize}

\item Das \emph{Common-Submodul} stellt Klassen bereit, die zur öffentlichen
Schnittstelle des Parsers zu anderen Modulen dienen. Dieses Submodul ist frei
von Abhängigkeiten zu jeglichen konkreten Parser-Implementierungen.

\item Mit dem \emph{Factory-Submodul} können neue, spezifische Parser erzeugt
werden.

\item Das \emph{RISC-V-Submodul} stellt eine konkrete Implementierung eines
Assemblierers für die RISC-V-Architektur zur Verfügung.

\item Im \emph{Independent-Submodul} sind viele Hilfsklassen (zum Beispiel
Symboltabellen, Compiler für arithmetische Ausdrücke) bereitgestellt, welche von
dem RISC-V-Parser verwendet, genauso gut aber auch gerne von zukünftigen Parser
eingebunden werden können.

\end{itemize}

Im Folgenden sind diese Submodule nochmal genauer ausgeführt:

\paragraph{Common-Submodul}

Das Kernstück des gesamten Moduls bildet die (abstrakte) Klasse \texttt{Parser}.
Diese bietet hauptsächlich zwei Funktionen: Anbieten von Syntax-Informationen
mittels der Methode \texttt{getSyntaxInformation} (für das Syntax-Highlighting in
der Benutzeroberfläche), sowie dem Assemblieren eines gegebenen
Assemblerprogrammes mithilfe der Methode \texttt{parse}, die als
Eingabeparameter einen C++-Standard-String erwartet.

\subparagraph{Syntax-Highlighting}

Beim Aufruf der Methode \texttt{getSyntaxInformation} soll ein Objekt der Klasse
\texttt{SyntaxInformation} erstellt und zurückgegeben werden. Dieses Objekt
enthält Informationen zum Syntax-Highlighting.

Zur Bestimmung der hervorzuhebenden Teile des Textes werden reguläre Ausdrücke
verwendet. Um unterschiedliche Formatierungen zu ermöglichen, wird jeder
Ausdruck einem Token (siehe \texttt{SyntaxInformation::Token}) zugeordnet.

Um einem \texttt{SyntaxInformation}-Objekt einen regulären Ausdruck hinzuzufügen,
kann die Methode \texttt{addSyntaxRegex} verwendet werden.

\subparagraph{Das Assemblieren}

Beim Aufruf der Methode \texttt{parse} soll das Assembler-Programm kompiliert
und in einer \texttt{FinalRepresentation}-Datenstruktur zurückgegeben werden.
Diese enthält notwendige Informationen für die Ausführung des
Assemblerprogrammes sowie dessen Darstellung in der Benutzeroberfläche. Die
\texttt{FinalRepresentation} besteht dabei aus folgenden Einzelheiten:

\begin{itemize}
\item \texttt{CommandList}: Die fertig assemblierten Assemblerbefehle,
aneinandergereiht. Jeder der Befehle (des Typs \texttt{FinalCommand}) enthält
einen fertig assemblierten \texttt{InstructionNode}, das
\texttt{CodePositionInterval}, an welchem der Befehl im Text auftritt, sowie die
Speicheradresse, an der der Befehl assembliert werden soll.
\item \texttt{MacroInformationList}: Beinhaltet alle Makros, welche im Code
vorkommen, mit eingesetzten Parametern und Position des Auftretens.
\item \texttt{CompileErrorList}: Eine Liste von allen Fehlern, Warnungen und
Hinweisen, die während des Assembliervorgangs aufgetreten sind. Wenn diese keine
Fehler enthält (sehrwohl aber eventuell Warnungen oder Hinweise), so ist das
Assemblieren erfolgreich gewesen und das Assemblerprogramm kann ausgeführt
werden.
\end{itemize}

Gehen wir noch auf ein paar Feinheiten ein:

Koordinaten im Assemblertext werden in der Datenstruktur \texttt{CodePosition}
als zweidimensionaler Punkt gespeichert, ein Intervall davon entsprechend in der
\texttt{CodePositionInterval}-Klasse. Ein Intervall ist genau dann leer, wenn
sein Startpunkt vor seinem Endpunkt liegt. In diesem Fall also, wenn die
Y-Koordinate des Endpunktes strikt kleiner als die des Startpunktes oder die
Y-Koordinaten identisch aber die X-Koordinate des Endpunktes strikt kleiner ist.
Ein \texttt{CodePositionInterval} wird beidseitig inklusiv gesehen (d.h. beide Randpunkte
liegen noch im Intervall).

Ein \texttt{CompileError} kapselt eine Fehlermeldung (bzw. eine Warnung oder
einen Hinweis). Dabei wird die Position und die Schwere der Meldung (Fehler,
Warnung, Hinweis, vgl. \texttt{Compile\-Error\-Severity}) festgehalten. Der Begriff
„Error“ ist deswegen etwas überladen. Die Meldung selber wird als
\texttt{Translateable} gespeichert, sodass diese später in verschiedene Sprachen
übersetzt werden könnte. Dabei werden Argumente separat vom eigentlichen
Text kodiert.

Eine \texttt{CompileErrorList} kapselt die
\texttt{CompileError}s und stellt Möglichkeiten zur Erweiterung der Liste
bereit. Dies erfolgt über den Aufruf von Makros. Der Grund hierfür ist, dass so
die Fehlermeldungen automatisch von einem Qt-Programm gefunden und für das
Übersetzen markiert werden können. Die Meldungen müssen dabei ein C-String sein
(\texttt{const char*}). Ebenso lassen sich über die \texttt{CompileErrorList}
einfache Abfragen stellen, ob jeweils Fehler, Warnungen oder Hinweise vorhanden
sind und wenn ja, wie viele.

\paragraph{Factory-Submodul}

Kommen wir zum Factory-Submodul: Dieses besteht lediglich aus einer einzigen
Klasse, der \texttt{ParserFactory}. Bei jener werden alle
Parserimplementierungen unter einem Namen zur Auswahl gestellt, sodass sie mit
Architektur und Speicherzugriff kombiniert einen Parser erzeugen können. Diese
Abhängigkeit zu den einzelnen Implementierungsmodulen ist auch der Grund, wieso
das Factory-Submodul aus dem Common-Submodul herausgenommen wurde.

Mit der Methode \texttt{ParserFactory::createParser} kann dabei ein Parser mit
den angegebenen Voraussetzungen generiert werden. Die Map
\texttt{ParserFactory::mapping} enthält alle registrierten Parser.

\paragraph{Independent-Submodul}

Kommen wir nun zum wohl größten Submodul des Parsers, dem
\emph{Independent}-Modul, welches eine Sammlung von Hilfsklassen darstellt,
welche von verschiedenen Assemblern verwendet werden können sollen. Dieses Modul
kann und soll gerne erweitert, dabei aber unabhängig von jeglichem spezifischen
Assemblierer gehalten werden.

\subparagraph{Intermediate-Darstellung für Befehle}

Das Independent-Submodul stellt Klassen zur Verfügung, die als
Übergangsdarstellung zwischen Text und assemblierten Syntaxbaum eines
Assembler-Programms dienen. Eine Übersicht der wichtigsten Klassen bietet
\autoref{fig:parser-intermediate}.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance=1.0cm and 0.7cm]

		\node (super) [class] {IntermediateOperation};
		\node (instr) [class, below = of super] {IntermediateInstruction};
		\node (macro) [class, right = of instr] {IntermediateMacroInstruction};
		\node (dir) [class, left = of instr] {IntermediateDirective};
		\node (sub) [below = of dir, yshift = 3mm, xshift = 1cm] {\textit{Diverse implementierte Direktiven}};

		\draw[inheritance-arrow] (dir.north) -- ++(0,0.5cm) -| (super);
		\draw[inheritance-arrow] (macro.north) -- ++(0,0.5cm) -| (super);
		\draw[inheritance-arrow] (instr.north) -- (super);
		\draw[inheritance-arrow] (sub.north) ++(-1.0cm,0) -- (dir);
		\end{tikzpicture}
	\end{center}
	\caption{Klassendiagramm Intermediate-Darstellung}
	\label{fig:parser-intermediate}
\end{figure}

Diese Klassen haben folgende Funktionen:

\begin{itemize}
	\item \texttt{IntermediateOperation} ist die abstrakte Oberklasse, die das
	Interface definiert.
	\item \texttt{IntermediateInstruction} steht für eine Maschineninstruktion,
	die vom Architekturmodul ausgewertet werden muss.
	\item \texttt{IntermediateMacroInstruction} steht für eine Instruktion,
	bei der es sich um einen Makroaufruf handelt. Diese Klasse muss nicht von
	einem Parser instanziiert werden (näheres im Abschnitt Makros).
	\item \texttt{IntermediateDirective} ist eine Oberklasse für
	Implementierungen von Parser-Direkti\-ven. Alle unterstützten Direktiven erben
	von dieser Klasse.
\end{itemize}

Die Klasse \texttt{IntermediateRepresentator} enthält eine Liste mehrerer
dieser Operationen und stellt eine Methode bereit, um diese Operationen in eine
\texttt{FinalRepresentation} umzuwandeln.

\subparagraph{Assemblierung der Intermediate-Darstellung}
Um die Operationen aus der Intermediate-Darstellung in ein Objekt der Klasse
\texttt{FinalRepresentation} umzuwandeln, kann die Funktion
\texttt{IntermediateRepresentator::\allowbreak{}transform} aufgerufen werden.
Diese Methode führt nacheinander folgende Schritte aus:

\begin{enumerate}
	\item Aufrufen der \texttt{precompile} Funktion für alle Operationen.
	\item Ersetzen aller Instruktionen, bei denen es sich um Makroaufrufe
	handelt, mit Makro-Instruktionen.
	\item Reservieren von Speicher für alle Befehle mit Hilfe der
	\texttt{allocateMemory} Funktion.
	\item Einlesen aller Labels/Konstanten und deren Werte mit der
	\texttt{enhanceSymbolTable} Funktion.
	\item "`Ausführen"' aller Operationen, d.h. meistens Erzeugen eines
	Syntaxknotens und Einfügen dieses Knotens in die \texttt{FinalRepresentation}
\end{enumerate}

\subparagraph{Makros}
Für das Parsen von Makros existieren zwei Direktiven: \texttt{Makro\-Directive}
und \texttt{Makro\-End\-Directive}. Alle Befehle zwischen diesen beiden
Direktiven werden in eine interne Liste des \texttt{Makro\-Directive}-Objekts
eingefügt, anstatt wie gewöhnlich in den \texttt{Intermediate\-Representator}.

Im \texttt{precompile}-Schritt trägt sich die Makro-Direktive mit ihrem Namen
in eine Tabelle (\texttt{Macro\-Directive\-Table}) ein. Daraufhin wird für jede
\texttt{Intermediate\-Instruction} überprüft, ob der Name ihres Befehls als
Makro in der Tabelle eingetragen ist. Falls ja, wird die Instruktion mit einer
\texttt{Intermediate\-Macro\-Instruction} ersetzt und alle Befehle aus der
Makro-Direktive nach Einsetzen von eventuellen Parametern in die neue
Makro-Instruktion kopiert.

Im \texttt{allocateMemory}- und \texttt{execute}-Schritt reicht die Makro-
Instruktion die Funktionsaufrufe einfach an die enthaltenen Instruktionen
weiter. Falls Fehler entstehen, werden diese an die Position des Makro-Aufrufs
verschoben.

\subparagraph{Symbolgraph und Symbol-Replacer}
\todo[inline]{TODO}

\subparagraph{Compiler für arithmetische Ausdrücke}
\todo[inline]{TODO}

\paragraph{RISC-V-Submodul}

Für RISC-V existiert ein korrespondierendes Parser-Submodul, welches in der
\texttt{ParserFactory} über den Namen \texttt{riscv} aufgerufen werden kann. Es
verwendet dabei größtenteils die Klassen, die im Independent-Submodul definiert
sind.

Der RISC-V-Parser liest zuerst zeilenweise den Programm-Code ein und speichert
ihn in einem \texttt{Intermediate\-Representator}. Dann wird die
\texttt{transform}-Funktion aufgerufen und die entstehende
\texttt{Final\-Representation} zurückgegeben.

Zum Parsen einer einzelnen Zeile wird die Hilfsklasse
\texttt{RiscvParser::\allowbreak{}RiscvRegex} verwendet. Diese Klasse nutzte
während der Entwicklung einen regulären Ausdruck, um die Zeile in
verschiedene Elemente aufzuteilen. Um bestimmte Einschränkungen dieses Vorgangs
zu umgehen, wurde die Klasse neu geschrieben, der Name aber beibehalten.

Nach aktuellem Stand wird über jedes Zeichen der zu parsenden Zeile iteriert und
bei gewissen Zeichen der letzte Teil der Zeile als Label, Instruktion oder
Parameter gespeichert. Hierbei werden beliebig viele Parameter unterstützt.

\subsubsection{Verwenden eines Parsers}

Von außen kann das Parser-Modul über die \texttt{ParserFactory} angesprochen
werden. Hier erzeugt man mit Name, Speicherzugriff und gegebener Architektur
einen gewünschten Parser und erhält einen Unique-Pointer darauf. Anschließend
kann man bereits die \texttt{parse}- und \texttt{getSyntaxHighliting}-Methoden
des Parsers selber aufrufen und Text assemblieren lassen. Das Deinitialisieren
erfolgt ebenfalls über den eingebauten Destruktor automatisch.

Eine Übersicht über diesen Prozess bietet \autoref{fig:parser-overview}.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance=1.0cm and 3.0cm]
		\tikzstyle{myarrow} = [->, thick]

		\node (factory) [class]
		{
			\textbf{ParserFactory}
		};
		\node (invis1) [empty, right = of factory] {};
		\node (parser) [class, rectangle split, rectangle split parts=2, below = of invis1]
		{
			\textbf{Parser}
			\nodepart{second}
			\begin{tabular}{c}
				getSyntaxInformation()
			\end{tabular}
		};
		\node (final) [class, rectangle split, rectangle split parts=2, right = of parser]
		{
			\textbf{FinalRepresentation}
			\nodepart{second}
			\begin{tabular}{c}
				commandList() \\
				errorList() \\
				macroList() \\
				\ldots
			\end{tabular}
		};
		\draw[myarrow] (factory) edge node [xshift=1.1cm, yshift=2mm] {createParser()} (parser);
		\draw[myarrow] (parser) edge node [yshift=2mm] {parse()} (final);
		\end{tikzpicture}
	\end{center}
	\caption{Übersicht der Parserschnittstelle}
	\label{fig:parser-overview}
\end{figure}

\subsubsection{Einschränkungen}

Trotz der aktuellen Fähigkeiten des Parser-Moduls existieren noch folgende
Einschränkungen:

\todo[inline]{TODO}
\begin{itemize}
\item \emph{Segment-Darstellung}: \todo[inline]{TODO}
\item \emph{Compiler für arithmetische Ausdrücke}: \todo[inline]{TODO}
\item \emph{Symbol-Tabelle}: \todo[inline]{TODO}
\item \emph{Gleitkommazahl-Unterstützung}: Unterstützung für Gleitkommezahlen
wurde während der Entwicklung aufgegeben, kann aber bei Bedarf leicht in den
Parser integriert werden.
\end{itemize}

\subsubsection{Weiterführende Dokumentation}

Weiterführende Dokumentation findet sich in denen für den Parser relevanten
Dateien, welche in \autoref{fig:parser-further} aufgelistet sind.

\begin{figure}[H]
	\begin{center}
	\begin{tikzpicture}[%
	grow via three points={one child at (0.8,-0.8) and
		two children at (0.8,-0.8) and (0.8,-1.7)},
	edge from parent path={($(\tikzparentnode\tikzparentanchor)+(.2cm,0pt)$) |- (\tikzchildnode\tikzchildanchor)},
	growth parent anchor=west,
	parent anchor=south west]
	\tikzstyle{every node}=[draw=black,anchor=west]
	\node {\erasim}
	child { node {$\{\text{tests/}, \text{include/}, \text{source/}\}$}
		child { node {parser/}
			child { node {common/} }
			child { node {factory/} }
			child { node {independent/} }
			child { node {riscv/} }
		}
	}
	child [missing] {}
	child [missing] {}
	child [missing] {};
	\end{tikzpicture}
	\end{center}

	\caption{Relevante Dateien des Parsermoduls}
	\label{fig:parser-further}
\end{figure}
