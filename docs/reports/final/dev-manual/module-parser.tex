\subsection{Parser}

Das \textit{Parser}-Modul übernimmt die Übersetzung des eingegebenen Textes in
die für das \textit{Architektur}-Modul lesbaren Syntaxbäume. Damit entspricht
dieses Modul größtenteils dem eigentlichen Assemblierer.

\subsubsection{Submodule}

Bei Erscheinen der Version 1.0 besteht das Parser-Modul aus vier verschiedenen Untermodulen:

\begin{itemize}

\item Das \emph{Common-Submodul} stellt Klassen bereit, die zur öffentlichen
Schnittstelle des Parsers zu anderen Modulen dienen. Dieses Submodul ist frei
von Abhängigkeiten zu jeglichen konkreten Parser-Implementierungen.

\item Mit dem \emph{Factory-Submodul} können neue, spezifische Parser erzeugt
werden.

\item Das \emph{RISC-V-Submodul} stellt eine konkrete Implementierung eines
Assemblierers für die RISC-V-Architektur zur Verfügung.

\item Im \emph{Independent-Submodul} sind viele Hilfsklassen (zum Beispiel
Symboltabellen, Compiler für arithmetische Ausdrücke) bereitgestellt, welche von
dem RISC-V-Parser verwendet, genauso gut aber auch gerne von zukünftigen Parser
eingebunden werden können.

\end{itemize}

Im Folgenden sind diese Submodule nochmal genauer ausgeführt:

\paragraph{Common-Submodul}

Das Kernstück des gesamten Moduls bildet die (abstrakte) Klasse \texttt{Parser}.
Diese bietet hauptsächlich zwei Funktionen: Anbieten von Syntax-Informationen
mittels der Methode \texttt{getSyntaxInformation} (für das Syntax-Highlighting in
der Benutzeroberfläche), sowie dem Assemblieren eines gegebenen
Assemblerprogrammes mithilfe der Methode \texttt{parse}, die als
Eingabeparameter einen C++-Standard-String erwartet.

\subparagraph{Syntax-Highlighting}

Beim Aufruf der Methode \texttt{getSyntaxInformation} soll ein Objekt der Klasse
\texttt{SyntaxInformation} erstellt und zurückgegeben werden. Dieses Objekt
enthält Informationen zum Syntax-Highlighting.

Zur Bestimmung der hervorzuhebenden Teile des Textes werden reguläre Ausdrücke
verwendet. Um unterschiedliche Formatierungen zu ermöglichen, wird jeder
Ausdruck einem Token (siehe \texttt{SyntaxInformation::Token}) zugeordnet.

Um einem \texttt{SyntaxInformation}-Objekt einen regulären Ausdruck hinzuzufügen,
kann die Methode \texttt{addSyntaxRegex} verwendet werden.

\subparagraph{Das Assemblieren}

Beim Aufruf der Methode \texttt{parse} soll das Assembler-Programm kompiliert
und in einer \texttt{FinalRepresentation}-Datenstruktur zurückgegeben werden.
Diese enthält notwendige Informationen für die Ausführung des
Assemblerprogrammes sowie dessen Darstellung in der Benutzeroberfläche. Die
\texttt{FinalRepresentation} besteht dabei aus folgenden Einzelheiten:

\begin{itemize}
\item \texttt{CommandList}: Die fertig assemblierten Assemblerbefehle,
aneinandergereiht. Jeder der Befehle (des Typs \texttt{FinalCommand}) enthält
einen fertig assemblierten \texttt{InstructionNode}, das
\texttt{CodePositionInterval}, an welchem der Befehl im Text auftritt, sowie die
Speicheradresse, an der der Befehl assembliert werden soll.
\item \texttt{MacroInformationList}: Beinhaltet alle Makros, welche im Code
vorkommen, mit eingesetzten Parametern und Position des Auftretens.
\item \texttt{CompileErrorList}: Eine Liste von allen Fehlern, Warnungen und
Hinweisen, die während des Assembliervorgangs aufgetreten sind. Wenn diese keine
Fehler enthält (sehrwohl aber eventuell Warnungen oder Hinweise), so ist das
Assemblieren erfolgreich gewesen und das Assemblerprogramm kann ausgeführt
werden.
\end{itemize}

Gehen wir noch auf ein paar Feinheiten ein:

Koordinaten im Assemblertext werden in der Datenstruktur \texttt{CodePosition}
als zweidimensionaler Punkt gespeichert, ein Intervall davon entsprechend in der
\texttt{CodePositionInterval}-Klasse. Ein Intervall ist genau dann leer, wenn
sein Startpunkt vor seinem Endpunkt liegt. In diesem Fall also, wenn die
Y-Koordinate des Endpunktes strikt kleiner als die des Startpunktes oder die
Y-Koordinaten identisch aber die X-Koordinate des Endpunktes strikt kleiner ist.
Ein \texttt{CodePositionInterval} wird beidseitig inklusiv gesehen (d.h. beide Randpunkte
liegen noch im Intervall).

Ein \texttt{CompileError} kapselt eine Fehlermeldung (bzw. eine Warnung oder
einen Hinweis). Dabei wird die Position und die Schwere der Meldung (Fehler,
Warnung, Hinweis, vgl. \texttt{Compile\-Error\-Severity}) festgehalten. Der Begriff
„Error“ ist deswegen etwas überladen. Die Meldung selber wird als
\texttt{Translateable} gespeichert, sodass diese später in verschiedene Sprachen
übersetzt werden könnte. Dabei werden Argumente separat vom eigentlichen
Text kodiert.

Eine \texttt{CompileErrorList} kapselt die
\texttt{CompileError}s und stellt Möglichkeiten zur Erweiterung der Liste
bereit. Dies erfolgt über den Aufruf von Makros. Der Grund hierfür ist, dass so
die Fehlermeldungen automatisch von einem Qt-Programm gefunden und für das
Übersetzen markiert werden können. Die Meldungen müssen dabei ein C-String sein
(\texttt{const char*}). Ebenso lassen sich über die \texttt{CompileErrorList}
einfache Abfragen stellen, ob jeweils Fehler, Warnungen oder Hinweise vorhanden
sind und wenn ja, wie viele.

\paragraph{Factory-Submodul}

Kommen wir zum Factory-Submodul: Dieses besteht lediglich aus einer einzigen
Klasse, der \texttt{ParserFactory}. Bei jener werden alle
Parserimplementierungen unter einem Namen zur Auswahl gestellt, sodass sie mit
Architektur und Speicherzugriff kombiniert einen Parser erzeugen können. Diese
Abhängigkeit zu den einzelnen Implementierungsmodulen ist auch der Grund, wieso
das Factory-Submodul aus dem Common-Submodul herausgenommen wurde.

Mit der Methode \texttt{ParserFactory::createParser} kann dabei ein Parser mit
den angegebenen Voraussetzungen generiert werden. Die Map
\texttt{ParserFactory::mapping} enthält alle registrierten Parser.

\paragraph{Independent-Submodul}

Kommen wir nun zum wohl größten Submodul des Parsers, dem
\emph{Independent}-Modul, welches eine Sammlung von Hilfsklassen darstellt,
welche von verschiedenen Assemblern verwendet werden können sollen. Dieses Modul
kann und soll gerne erweitert, dabei aber unabhängig von jeglichem spezifischen
Assemblierer gehalten werden.

\subparagraph{Intermediate-Darstellung für Befehle}

Das Independent-Submodul stellt Klassen zur Verfügung, die als
Übergangsdarstellung zwischen Text und assemblierten Syntaxbaum eines
Assembler-Programms dienen. Eine Übersicht der wichtigsten Klassen bietet
\autoref{fig:parser-intermediate}.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance=1.0cm and 0.7cm]

		\node (super) [class] {IntermediateOperation};
		\node (instr) [class, below = of super] {IntermediateInstruction};
		\node (macro) [class, right = of instr] {IntermediateMacroInstruction};
		\node (dir) [class, left = of instr] {IntermediateDirective};
		\node (sub) [below = of dir, yshift = 3mm, xshift = 1cm] {\textit{Diverse implementierte Direktiven}};

		\draw[inheritance-arrow] (dir.north) -- ++(0,0.5cm) -| (super);
		\draw[inheritance-arrow] (macro.north) -- ++(0,0.5cm) -| (super);
		\draw[inheritance-arrow] (instr.north) -- (super);
		\draw[inheritance-arrow] (sub.north) ++(-1.0cm,0) -- (dir);
		\end{tikzpicture}
	\end{center}
	\caption{Klassendiagramm Intermediate-Darstellung}
	\label{fig:parser-intermediate}
\end{figure}

Diese Klassen haben folgende Funktionen:

\begin{itemize}
	\item \texttt{IntermediateOperation} ist die abstrakte Oberklasse, die das
	Interface definiert.
	\item \texttt{IntermediateInstruction} steht für eine Maschineninstruktion,
	die vom Architekturmodul ausgewertet werden muss.
	\item \texttt{IntermediateMacroInstruction} steht für eine Instruktion,
	bei der es sich um einen Makroaufruf handelt. Diese Klasse muss nicht von
	einem Parser instanziiert werden (näheres im Abschnitt Makros).
	\item \texttt{IntermediateDirective} ist eine Oberklasse für
	Implementierungen von Parser-Direkti\-ven. Alle unterstützten Direktiven erben
	von dieser Klasse.
\end{itemize}

Die Klasse \texttt{IntermediateRepresentator} enthält eine Liste mehrerer
dieser Operationen und stellt eine Methode bereit, um diese Operationen in eine
\texttt{FinalRepresentation} umzuwandeln.

\subparagraph{Assemblierung der Intermediate-Darstellung}
\label{sec:dev_parser_assem_inter}
Um die Operationen aus der Intermediate-Darstellung in ein Objekt der Klasse
\texttt{FinalRepresentation} umzuwandeln, kann die Funktion
\texttt{IntermediateRepresentator::\allowbreak{}transform} aufgerufen werden.
Diese Methode führt nacheinander folgende Schritte aus:

\begin{enumerate}
	\item Aufrufen der \texttt{precompile} Funktion für alle Operationen.
	\item Ersetzen aller Instruktionen, bei denen es sich um Makroaufrufe
	handelt, mit Makro-Instruktionen.
	\item Reservieren von Speicher für alle Befehle mit Hilfe der
	\texttt{allocateMemory} Funktion.
	\item Einlesen aller Labels/Konstanten und deren Werte mit der
	\texttt{enhanceSymbolTable} Funktion.
	\item "`Ausführen"' aller Operationen mit der \texttt{execute}-Funktion,
	d.h. meistens Erzeugen eines Syntaxknotens und Einfügen dieses Knotens in
	die \texttt{FinalRepresentation}.
\end{enumerate}

\subparagraph{Makros}
Für das Parsen von Makros existieren zwei Direktiven: \texttt{Makro\-Directive}
und \texttt{Makro\-End\-Directive}. Alle Befehle zwischen diesen beiden
Direktiven werden in eine interne Liste des \texttt{Makro\-Directive}-Objekts
eingefügt, anstatt wie gewöhnlich in den \texttt{Intermediate\-Representator}.

Im \texttt{precompile}-Schritt trägt sich die Makro-Direktive mit ihrem Namen
in eine Tabelle (\texttt{Macro\-Directive\-Table}) ein. Daraufhin wird für jede
\texttt{Intermediate\-Instruction} überprüft, ob der Name ihres Befehls als
Makro in der Tabelle eingetragen ist. Falls ja, wird die Instruktion mit einer
\texttt{Intermediate\-Macro\-Instruction} ersetzt und alle Befehle aus der
Makro-Direktive nach Einsetzen von eventuellen Parametern in die neue
Makro-Instruktion kopiert.

Im \texttt{allocateMemory}- und \texttt{execute}-Schritt reicht die Makro-
Instruktion die Funktionsaufrufe einfach an die enthaltenen Instruktionen
weiter. Falls Fehler entstehen, werden diese an die Position des Makro-Aufrufs
verschoben.

\subparagraph{Symbolgraph und Symbol-Replacer}
Für das Vermerken und Einsetzen von Symbolen wie Labels oder Konstanten existiert mit den Klassen \texttt{SymbolGraph} und \texttt{SymbolReplacer} ein eigenes System. Dieses kann ausschließlich nichtparametrisierte Symbole verarbeiten (d.h. Funktionen sind nicht möglich). Ein Symbol ist in unserem Fall ein Name, der für einen anderen Namen oder Wert steht.

Zum Generieren eines \texttt{SymbolReplacer}s zum Ersetzen von Symbolen baut man einen \texttt{SymbolGraph} mit allen einzufügenden Symbolen auf (Klasse \texttt{Symbol}). Der \texttt{SymbolGraph} selber besteht dann aus den einzelnen Symbole als Knoten und Abhängigkeiten zwischen ihnen als Kanten. Ein Symbol A ist dabei abhängig von einem Symbol B, wenn B in dem Ersetzungstext von A vorkommt. Im Symbolgraph würde hier dann eine Kante von B nach A geleitet werden. Anschließend können wir unseren \texttt{SymbolGraph} evaluieren. Dabei werden folgende Dinge überprüft:
\begin {itemize}
\item Sind die Namen (orientiert an C, d.h. Buchstabe oder _ als erstes Zeichen, danach beliebig viele davon incl. von Zahlen) gültig?
\item Existiert einer/mehrere Namen doppelt?
\item Existiert eine zyklische Abhängigkeit unter den Symbolen (bzw. im Symbolgraph)?
\end {itemize}

Während erste und zweite Eigenschaft leicht per Iterieren über die Symbole bzw. Einteilen in Äquivalenzklassen dieser (z.B. mittels einer Map) gelöst werden kann, ist es für die dritte Eigenschaft nötig, den Symbolgraphen zu betrachten (bzw. sie ist überhaupt der Grund, dass wir uns so einen Graphen generiert haben): Wir überprüfen hierzu, ob unser nicht zwingend zusammenhängende Digraph (gerichteter Graph) kreisfrei ist. Dazu lassen wir über jede Zusammenhangskomponente eine Tiefensuche laufen und merken uns den PFad zu unserem Startknoten. Wenn wir nun auf einen Knoten suchen, der in unserem Pfad bereits ist, so haben wir einen Kreis und geben das so weiter. Kommen wir ohne Kreise durch, so geben wir noch die topologische Sortierung unserer Knoten zurück (diese entspricht der umgedrehten Reihenfolge, in der wir die Knoten abgeschlossen haben). Die topologische Sortierung ist in unserem Fall genau eine Anordnung der Symbole, sodass das Symbol an Position $$i$$ nur von allen Symbolen im Bereich $$\{0,...,i-1\}$$ abhängt. Damit können wir nun unsere Symbole insgesamt vereinfachen: Wir iterieren vorwärts über alle Symbole und setzen in Symbol $$s_i$$ alle Symbole ein, von denen $$s_i$$ abhängt. Wir wissen dabei, wegen der topologischen Sortierung, dass $$s_i$$ nur von $$s_0,...,s_{i-1}$$ abhängt und diese Symbole haben wir schon soweit wie möglich ersetzt. Damit erhalten wir am Ende eine Darstellung, in der die Symbole weitestmöglich ersetzt sind. Diese können wir dan weitergeben an das Ersetzungssystem. Wir unterscheiden dabei noch zwischen statischen und dynamischen Symbolen: Statische Symbole haben dabei einen unveränderlichen Wert und werden daher wie geplant ersetzt. Für dynamische Symbole ist der Wert jedoch erst beim Ersetzen des Symbols im Programm bekannt, nicht bereits, wenn der Symbolgraph ausgewertet wird. Daher werden diese Symbole \emph{nicht ersetzt} (sehrwohl aber auf wohlgeformte Namen und Duplikate geprüft), sondern verbleiben mit ihrem Namen in den weitestmöglich ersetzten Symbolen. Ein Einsatzzweck für solche dynamischen Symbole sind zum Beispiel relative Adressen: Da beim Generieren des Graphen nicht bekannt ist, bei welchen Befehlen das Symbol zum Einsatz kommt, kann es nicht ersetzt werden. All dies erfolgt, wenn man \texttt{evaluate} beim Symbolgraphen aufruft. Würden wir nun parametrisierte Symbole zulassen, so hätten wir das Problem, dass wir hier selbst bei statischen Symbolen nicht feststellen können, ob ein Ersetzungsvorgang irgendwann beendet ist (vgl. Halteproblem, sowas ist sogar \emph{beweisbar} nicht möglich), also müssten wir ab irgendeiner Ersetzungstiefe abbrechen. Dennoch stünde es für zukünftige Generationen frei, dies zu implementieren.

Die Evaluierung (Klasse \texttt{SymbolGraphEvaluation}) wird anschließend an den SymbolReplacer weitergegeben. Dieser ersetzt textuell bei einem gegebenen Eingabestring alle Symbolvorkommen über mehrere Iterationen hinweg, denn es ist ja auch möglich, dass ein dynamisches Symbol zu einem weiteren dynamischen Symbol expandiert (wenn auch noch kein solcher Fall bekannt ist). In der Tat ist es wegen der Natur der dynamischen Symbole ebenfalls nicht möglich, zu sehen, ob eine Ersetzung mit Sicherheit terminiert (vgl. oben). Also brechen wir nach einer bestimmten Anzahl an Ersetzungsiterationen (standardmäßig auf 4 gesetzt) ab und geben einen Fehler zurück. Anmerkung: Die textuelle Ersetzungs ist noch alles andere als ideal, besser wäre, wenn die Ersetzung ausschließlich auf einem Stream von Tokens (siehe nächsten Abschnitt) arbeiten würde (und auch einen solchen zurückgibt).

\subparagraph{Compiler für arithmetische Ausdrücke}
Neben Symbolersetzung enthält die \texttt{independent}-Bibliothek auch ein System, um arithmetische Ausdrücke zu verarbeiten. Es handelt sich dabei um die Klasse \texttt{ExpressonCompiler} bzw. ihre Instanziierungen.



\paragraph{RISC-V-Submodul}

Für RISC-V existiert ein korrespondierendes Parser-Submodul, welches in der
\texttt{ParserFactory} über den Namen \texttt{riscv} aufgerufen werden kann. Es
verwendet dabei größtenteils die Klassen, die im Independent-Submodul definiert
sind.

Der RISC-V-Parser liest zuerst zeilenweise den Programm-Code ein und speichert
ihn in einem \texttt{Intermediate\-Representator}. Dann wird die
\texttt{transform}-Funktion aufgerufen und die entstehende
\texttt{Final\-Representation} zurückgegeben.

Zum Parsen einer einzelnen Zeile wird die Hilfsklasse
\texttt{RiscvParser::\allowbreak{}RiscvRegex} verwendet. Diese Klasse nutzte
während der Entwicklung einen regulären Ausdruck, um die Zeile in
verschiedene Elemente aufzuteilen. Um bestimmte Einschränkungen dieses Vorgangs
zu umgehen, wurde die Klasse neu geschrieben, der Name aber beibehalten.

Nach aktuellem Stand wird über jedes Zeichen der zu parsenden Zeile iteriert und
bei gewissen Zeichen der letzte Teil der Zeile als Label, Instruktion oder
Parameter gespeichert. Hierbei werden beliebig viele Parameter unterstützt.

\subsubsection{Verwenden eines Parsers}

Von außen kann das Parser-Modul über die \texttt{ParserFactory} angesprochen
werden. Hier erzeugt man mit Name, Speicherzugriff und gegebener Architektur
einen gewünschten Parser und erhält einen Unique-Pointer darauf. Anschließend
kann man bereits die \texttt{parse}- und \texttt{getSyntaxHighliting}-Methoden
des Parsers selber aufrufen und Text assemblieren lassen. Das Deinitialisieren
erfolgt ebenfalls über den eingebauten Destruktor automatisch.

Eine Übersicht über diesen Prozess bietet \autoref{fig:parser-overview}.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance=1.0cm and 3.0cm]
		\tikzstyle{myarrow} = [->, thick]

		\node (factory) [class]
		{
			\textbf{ParserFactory}
		};
		\node (invis1) [empty, right = of factory] {};
		\node (parser) [class, rectangle split, rectangle split parts=2, below = of invis1]
		{
			\textbf{Parser}
			\nodepart{second}
			\begin{tabular}{c}
				getSyntaxInformation()
			\end{tabular}
		};
		\node (final) [class, rectangle split, rectangle split parts=2, right = of parser]
		{
			\textbf{FinalRepresentation}
			\nodepart{second}
			\begin{tabular}{c}
				commandList() \\
				errorList() \\
				macroList() \\
				\ldots
			\end{tabular}
		};
		\draw[myarrow] (factory) edge node [xshift=1.1cm, yshift=2mm] {createParser()} (parser);
		\draw[myarrow] (parser) edge node [yshift=2mm] {parse()} (final);
		\end{tikzpicture}
	\end{center}
	\caption{Übersicht der Parserschnittstelle}
	\label{fig:parser-overview}
\end{figure}

\subsubsection{Einschränkungen}

Trotz der aktuellen Fähigkeiten des Parser-Moduls existieren noch folgende
Einschränkungen:

\todo[inline]{TODO}
\begin{itemize}
\item \emph{Segment-Darstellung}: \todo[inline]{TODO}
\item \emph{Compiler für arithmetische Ausdrücke}: \todo[inline]{TODO}
\item \emph{Symbol-Tabelle}: \todo[inline]{TODO}
\item \emph{Gleitkommazahl-Unterstützung}: Unterstützung für Gleitkommezahlen
wurde während der Entwicklung aufgegeben, kann aber bei Bedarf leicht in den
Parser integriert werden.
\end{itemize}

\subsubsection{Weiterführende Dokumentation}

Weiterführende Dokumentation findet sich in denen für den Parser relevanten
Dateien, welche in \autoref{fig:parser-further} aufgelistet sind.

\begin{figure}[H]
	\begin{center}
	\begin{tikzpicture}[%
	grow via three points={one child at (0.8,-0.8) and
		two children at (0.8,-0.8) and (0.8,-1.7)},
	edge from parent path={($(\tikzparentnode\tikzparentanchor)+(.2cm,0pt)$) |- (\tikzchildnode\tikzchildanchor)},
	growth parent anchor=west,
	parent anchor=south west]
	\tikzstyle{every node}=[draw=black,anchor=west]
	\node {\erasim}
	child { node {$\{\text{tests/}, \text{include/}, \text{source/}\}$}
		child { node {parser/}
			child { node {common/} }
			child { node {factory/} }
			child { node {independent/} }
			child { node {riscv/} }
		}
	}
	child [missing] {}
	child [missing] {}
	child [missing] {};
	\end{tikzpicture}
	\end{center}

	\caption{Relevante Dateien des Parsermoduls}
	\label{fig:parser-further}
\end{figure}
